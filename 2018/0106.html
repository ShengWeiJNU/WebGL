<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>perlin noise GLSL</title>
<style type="text/css">
body, html{
	margin: 0;
}
canvas{
	display: block;
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script type="text/javascript">
/**
 * 3D perlin noise generate algorithm, inventor Ken Perlin.
 * blog url: www.jianshu.com/p/27e29d50116b
 * wrote on 2017-11-18 by bibibobo
 * alogrithm steps:
 *     1.restrict the x、y、z to [0, range-1);
 *	   2.
**/


/** permutation: []
 * 
 * @ description: a permutation table(排列表).
 * @ length: 256
 * @ value: random and no-repeat numbers from [0, 255]
**/
var permutation = [];
var all = [];
for(let i=0; i<256; i++){
	all[i] = i;
}
while(all.length){
	let v = all.splice(~~(Math.random()*all.length), 1)[0];
	permutation.push(v);
}

/** p: []
 * 
 * @ description: will be used for calculating hash.
 * @ length: 512
 * @ value: repeat permutation[]
**/
var p = [];
(function(){
  for(let i=0; i<512; i++){
    p[i] = permutation[i%256];
  }
})();

// the input param will be restricted to [0, repeat)
var repeat = 5;

/**
 * @ description: the perlin function
 * @ params: x: float, y: float, z: float
 * @ return: [0,1]
**/
function perlin(x, y, z){
  if(repeat > 0){
    x = x % repeat;
    y = y % repeat;
    z = z % repeat;
  }
  var xi = (~~x) & 255;
  var yi = (~~y) & 255;
  var zi = (~~z) & 255;
  var xf = x - ~~x;
  var yf = y - ~~y;
  var zf = z - ~~z;
  
  var u = fade(xf);
  var v = fade(yf);
  var w = fade(zf);
  
  var aaa, aab, aba, abb, baa, bab, bba, bbb;
  aaa = p[p[p[xi]+yi]+zi];
  aab = p[p[p[xi]+yi]+inc(zi)];
  aba = p[p[p[xi]+inc(yi)]+zi];
  abb = p[p[p[xi]+inc(yi)]+inc(zi)];
  baa = p[p[p[inc(xi)]+yi]+zi];
  bab = p[p[p[inc(xi)]+yi]+inc(zi)];
  bba = p[p[p[inc(xi)]+inc(yi)]+zi];
  bbb = p[p[p[inc(xi)]+inc(yi)]+inc(zi)];
  
  var x1, x2, y1, y2;
  x1 = lerp(grad(aaa,xf,yf,zf), grad(baa,xf-1,yf,zf), u);
  x2 = lerp(grad(aba,xf,yf-1,zf), grad(bba,xf-1,yf-1,zf), u);
  y1 = lerp(x1, x2, v);
  x1 = lerp(grad(aab,xf,yf,zf-1), grad(bab,xf-1,yf,zf-1), u);
  x2 = lerp(grad(abb,xf,yf-1,zf-1), grad(bbb,xf-1,yf-1,zf-1), u);
  y2 = lerp(x1, x2, v);
  return (lerp(y1,y2,w) + 1) / 2;
}

/**
 * @ description: ease function 6t^5 - 15t^4 + 10t^3
 * @ param: t:[0,1]
 * @ return: [0,1]
**/
function fade(t){
  return t * t * t * (t * (t * 6 - 15) + 10);
}

function inc(num){
  num ++;
  if(repeat > 0)
    num %= repeat;
  return num;
}

function grad(hash, x, y, z){
  var h = hash & 15;
  var u = h<8 ? x : y;
  var v;
  if(h < 4)
    v = y;
  else if(h==12 || h==14)
    v = x;
  else
    v = z;
  return ((h&1)==0?u:-u) + ((h&2)==0?v:-v);
}

function lerp(a, b, x){
  return a + (b-a) * x;
}

function octavePerlin(x, y, z, octaves, persistence=2){
  var total=0, frequency=1, amplitude=1, maxValue=0;
  for(let i=0; i<octaves; i++){
    total += perlin(x*frequency, y*frequency, z*frequency) * amplitude;
    maxValue += amplitude;
    amplitude *= persistence;
    frequency *= 2;
  }
  return total / maxValue;
}


var can = document.getElementById('canvas');
var cw = can.width = window.innerWidth;
var ch = can.height = window.innerHeight;
var ctx = can.getContext('2d');
var piecesX=100, piecesY=100;
var ew = cw / piecesX;
var eh = ch / piecesY;
var q = [];
var depth = 1800;
var z = [];
for(let i=0; i<depth; i++){
	z[i] = i / depth * repeat;
}
for(let k=0; k<depth; k++){
	q[k] = [];
	for(let i=0; i<piecesX; i++){
		q[k][i] = [];
		for(let j=0; j<piecesY; j++){
			q[k][i][j] = perlin((i+1)*ew/cw, (j+1)*eh/ch, z[k]);
		}
	}
}
var n = 0;
var dir = 1;
var frameCount = 0;
console.time('a');
requestIdleCallback(function loop(){
	// ctx.clearRect(0, 0, cw, ch);
	for(let i=0; i<piecesX; i++){
		for(let j=0; j<piecesY; j++){
			ctx.fillStyle = "hsl(" + q[n][i][j]*360 + ",100%,50%)";
			// ctx.fillStyle = "rgba("+q[n][i][j]*360+","+q[n][i][j]*360+","+q[n][i][j]*360+","+q[n][i][j]+")";
			ctx.fillRect(i*ew, j*eh, ew, eh);
		}
	}
	n += dir;
	if(n>=depth || n<0){
		dir = -dir;
		n += dir;
	}
	frameCount ++;
	requestIdleCallback(loop);
});

setTimeout(function(){
	console.timeEnd('a');
	console.log(frameCount / 10);
}, 10000);
</script>
</body>
</html>